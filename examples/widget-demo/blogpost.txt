# This is the draft of the blog post associated with this demo.
# after publishing the post, this file will be deleted.
# ------------------------------------------------------------------------------

Part 1:
    JavaScript Widget Development Best Practices (Part 1: Overview)
    http://o2js.com/2012/07/05/javascript-widgets-overview/

Part 2:
    JavaScript Widget Development Best Practices (Part 2: the Setup)
    http://o2js.com/2012/07/16/javascript-widgets-setup/

Part 3:
    In the former post we've outline a broad brushstrokes initialization flow
    of our external JavaScript widget. We've created a basic bootloader script
    that first loads required resources asynchronously and then continues with
    the initialization and rendering of the widget (which are yet to be
    implemented)

    Now it's time to tackle a common problem
    for any script that you want to constantly upgrade an develop: Versioning
    and Caching.

    For our external widget script to be responsive, and load faster it's a good
    practice to serve the widget script with a far future expires header.

    http://developer.yahoo.com/performance/rules.html/

    "
    For static components: implement "Never expire" policy by setting far future
    Expires header

    A first-time visitor to your page may have to make several HTTP requests,
    but by using the Expires header you make those components cacheable.
    This avoids unnecessary HTTP requests on subsequent page views.

    Expires headers are most often used with images, but they should be used
    on all components including scripts, stylesheets, and Flash components.

    Browsers (and proxies) use a cache to reduce the number and size of HTTP
    requests, making web pages load faster
    "
    However there's one complication with setting a far future expires header:
    If you change your widget code, the users may still be using older versions
    of your bootloader.

    One approach is to change the version of the widget after every change and
    to ask publishers to update their widget loader script to reflect the
    change accordingly.

    //add sample code.

    Assume that it's a critical security update. You cannot take it as a given
    that all the publishers will increment the API version that they are loading
    in their initialization scripts. From former experience, I can say that
    some of the publishers do not bother changing the API version and use older
    version of the API regardless of the missing features.

    We'll approach the problem as follows:

    - We'll create a cache revalidation mechanism to push hotfixes, bugfixes,
    improvements and non-breaking changes to the current version of the API.

    - And we'll increment the version number of the bootloader script
    for major improvements, and breaking changes.

    First start with setting a very long expires header for our static API
    bootloader.

    //index.js
    /*
     * Make sure that the static assets have a far future expiration date.
     */
    app.use(
        express['static'](
            path.STATIC_FILE,
            config.farFutureExpiration
        )
    )

    //where config is:
    var config = {
        farFutureExpiration : {maxAge : kOneYear},

        api_v_0_1 : {
            VERSION_TIMESTAMP : '20120720135547909116'
        }
    };

    We'll com to what VERSION_TIMESTAMP is in a minute.

    And when we request the api.v.0.1.js Here's the response headers we get:

    Accept-Ranges   bytes
    Cache-Control   public, max-age=31536000
    Connection      keep-alive
    Content-Length  6672
    Content-Type    application/javascript
    Date            Fri, 20 Jul 2012 20:41:55 GMT
    Etag            "6672-1342801807000"
    Last-Modified   Fri, 20 Jul 2012 16:30:07 GMT
    X-Powered-By    Express

    Where the

    Cache-Control   public, max-age=31536000

    indicates that our bootloader script will be cached for 1 year.

    If we refresh the webpage and analyze the browser cache, we'll see
    that it's in deed true.

    Cache:
    Data Size       6672
    Device          disk
    Expires         Sat Jul 20 2013 23:43:10 GMT+0300 (EEST)
    Fetch Count     4
    Last Fetched    Fri Jul 20 2012 23:43:11 GMT+0300 (EEST)
    Last Modified   Fri Jul 20 2012 23:43:10 GMT+0300 (EEST)

    We'll get a 304 Not Modified response from the server.
        http://www.checkupdown.com/status/E304.html

    You can read http://www.mnot.net/cache_docs/ for caching best practices
    and read http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html for
    HTTP status codes.

    http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
    http header field definitions

    http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
    status code definitions

    Now it's time to implement a self updating bootloader script
    <link to soulders>
    http://www.stevesouders.com/blog/2012/05/22/self-updating-scripts/

    Let's add a version timestamp to the API first:

    (function(window, document, isDebugMode) {
        ...

        /*
         * Should match beacon version timestamp.
         * See the <insert-link-here> for details.
         */
        var versionTimestamp = '20120720135547909116';

    And then pass along that version timestamp to load a cache validator beacon:

    /*
     * Revalidates cache for this bootloader script, if there's a newer
     * version available. The changes will take effect only AFTER the user
     * refreshes the page.
     */
    function checkForUpdates() {
        log('o->checkForUpdates()');

        insertScript(kApiRoot, [kBeacon, kQuery,
            kVersion,  kEquals, versionTimestamp , kAnd,
            kRandom,   kEquals, (new Date()).getTime()
        ].join(kEmpty), noop);
    }

    Where the constants above (and some more) are defined as follows:

    var kAnd            = '&';
    var kApiRoot        = 'http://api.widget.www/';
    var kBeacon         = 'api/v.0.1/beacon';
    var kCompleteRegExp = /loaded|complete/;
    var kEmpty          = '';
    var kEquals         = '=';
    var kHead           = 'head';
    var kO2Root         = 'http://api.widget.www/lib/o2.js/';
    var kQuery          = '?';
    var kRandom         = 'r';
    var kScript         = 'script';
    var kScriptType     = 'text/javascript';
    var kVersion        = 'v';

    So we basically call

    insertScript(
        'http://api.widget.www/api/v.0.1/beacon?v=20120720135547909116&r={#}'
    );

    Where insertScript simply does what its name implies:

    /*
     * Asynchronously inserts a script element to the head
     * of the document.
     */
    function insertScript(root, src) {
        var s = document.createElement(kScript);
        var x = document.getElementsByTagName(kScript)[0] ||
            document.getElementsByTagName(kHead)[0];

        s.type  = kScriptType;
        s.async = true;
        s.src   = [root, src].join(kEmpty);

        x.parentNode.insertBefore(s, x);

        return s;
    }

    So what we do is to request a beacon script at each widget load.

    Now let's look at what the beacon script does:

    /**
     * Beacon to validate the cache of the JS API.
     */
    app.get(v_0_1(route).BEACON, function(req, res) {
        res.header('Content-Type', 'text/javascript');

        setShortExpiresHeader(res);

        var versionTimestamp = v_0_1(config).VERSION_TIMESTAMP;

        var requestedVersion = req.param(
            parameter.VERSION,
            versionTimestamp
        );

        if (requestedVersion !== versionTimestamp) {
            res.render(template.UPDATE_SCRIPT, {
                iframeUrl : v_0_1(url).UPDATE_IFRAME
            });

            return;
        }

        res.send(204);
    });

    So if the requested version timestamp is identical to the what we sent,
    then it means that we are using the most up-to-date bootloader script
    adn we don't need to update the cache.
    So the beacon simply sends a HTTP 204 (no content) response.

    Otherwise (i.e. if the versions don't match) then we conclude that the
    cache is stale and we inject a simple javascript as follows:

    (function() {
        var update = function() {
            if (!document.body) {
                setTimeout(update, 500);
                return;
            }

            var loader = document.createElement('iframe');

            loader.style.display = 'none';
            loader.src = '#{iframeUrl}';

            document.body.appendChild(loader);
        };

        update();
    })();

    Where we append a hidden IFRAME to the document.
    And the contents of the IFRAME would be (in Jade syntax):

    !!! 5
    html(lang='en')
        head
            script(src= apiBootstrapUrl)
        body(lang='en')
            script
                if (!window.location.hash) {
                    window.location.hash = 'checked';
                    window.location.reload(true);
                }

    So the iframe simply reloads the api bootloader script once more to
    update the browser's cache. So a newer version of the script will be served
    to the end user once she reloads the publisher's website, or navigates
    to another page.

    ...

    // To avoid re-defining everything if the bootloader is included in
    // more than one place in the publisher's website.
    if (window._wd) {
        return;
    }

    window._wd = {};


    Load Resources:

    /*
     * Load necessary o2.js components in noConflict mode.
     */
    function getPrerequisites(callback) {
        log('o->getPrerequisites(');
        log(callback);
        log(')');

        loadScripts(kO2Root, [
            'o2.meta.js',
            'o2.core.js'
        ], callback);
    }

    /*
     * Loads an array of scripts one after another.
     */
    function loadScripts(root, ar, callback) {
        log('o->loadScripts(');
        log(root);
        log(ar);
        log(callback);
        log(')');

        scriptQueue = ar;

        loadScript(root, scriptQueue.shift(), callback);
    }

    /*
     * Loads the given script.
     * <strong>callback</strong> is the function to be executed after
     * there's no resource left to be loeded next.
     */
    var loadScript = function(root, src, callback) {
        log('o->loadScript(');
        log(root);
        log(src);
        log(callback);
        log(')');

        var s = insertScript(root, src);

        function processNext() {
            loadNext(root, loadScript, callback);
        }

        s.onreadystatechange = function() {
            if(kCompleteRegExp.test(s.readyState)) {
                processNext();
            }
        };

        s.onload = function() {
            processNext();
        };
    };

    Next up?

        - get widget parameters
        - implement a job queue
        - render initial widget state


204 No Content

304 not modified
http://www.checkupdown.com/status/E304.html


samples:
    ga.js has a 2 hour cache time
    Facebook's all.js has a 15 minute cache time
    Twitter's widgets.js has a 30 minute cache time

our widget should have a far future cache time (explain why.)

    Now let's implement cache validation:




    // TODO:
    //     async request to a beacon.js (will have nocache,must-revalidate
    //     cache control headers)



    {{implement cache validation}}
    {{test for edge cases: what if publisher includes scripts more than once
    what if there is no HEAD element, what if whatever...?}}

Part 4:

    {{ways to store and retrieve widget paremeters}}
    {{get widget state/model from the server
        corollary: create a communication channel.
            different sorts of channels.
    }}
    {{render widget}}

Part 5:

    {{handling sessions}}
    {{how to authenticate user}}
    {{third party cookies}}

Part 6:

    {{retrieving data from server, modifying it, persisting it to server}}
    {{modern ways of cross-domain cross-frame communication}}
    {{fallback methods}}

Part 7:
    {{Deployment and Minification}}
    {{Versioning}}


---- supporting text -------

- cross-domain messaging alternatives (klein bottle)
- (at any phase mention all approaches and use the simplest one)

http://www.stevesouders.com/blog/2012/05/22/self-updating-scripts/

caching issues:
A bootstrap script is defined as a 3rd party script with a hardwired URL that can’t be changed. We want to give these scripts long cache times so they don’t slow down the page, but we also want the cached version to get updated when there’s a change. There are two main problems to solve: notifying the browser when there’s an update, and replacing the cached bootstrap script with the new version.
via:

--- supporting text ---

first (ideal case)
    authenticate user,
    remember the user.

seamless iframes:
    http://benvinegar.github.com/seamless-talk/#/39
    for those who want consistent styling and a stricter control in a
    well-defined sandbox environment.

a node.js application that
1. asks for credentials of the user.
2. displays logged in gui
3. resdisplays the logged in gui after refresh
4. the gui will have name surname and details of the user and an editable
text area
5. the text will update after user tpyes stuff
6. refreshing will retrieve the updated text from server.


- ideal case: 3rd party cookies are enabled
- detect whether they are enabled
- if disabled
    use cross frame messaging api if supported
    otherwise use klein bottle.

    mention that these should be enough and cross frame messaging api appears
    to be more widely supported in the future.

    mention easyxdm as well.


my next blog post will be about JS widgets for external sites.


TODO: look at notational data links as well.


1. What is a JavaScript Widget

2. Typical Use Cases for JavaScript Widgets

3. Challenges


Minification

split into logical pieces,
use modules
-- give examples


do use namespaces --
-- give examples