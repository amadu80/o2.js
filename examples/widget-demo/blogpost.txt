# This is the draft of the blog post associated with this demo.
# after publishing the post, this file will be deleted.
# ------------------------------------------------------------------------------

Part 1:
    JavaScript Widget Development Best Practices (Part 1: Overview)
    http://o2js.com/2012/07/05/javascript-widgets-overview/

Part 2:
    JavaScript Widget Development Best Practices (Part 2: the Setup)
    http://o2js.com/2012/07/16/javascript-widgets-setup/

Part 3:
    JavaScript Widget Development Best Practices (Part 3: Cache Revalidation)
    http://o2js.com/2012/07/22/javascript-widgets-cache/

Part 4:
    JavaScript Widget Development Best Practices (Part 4: Cross-Domain Communication)
    http://o2js.com/2012/07/27/javascript-widgets-cross-frame/

Part 5:
    In the former article we have seen different ways to send initialization
    parameters to our widget, and we have also listed several techniques on
    how to establish cross-domain communication between the publisher's site
    and the widget API server. In this article we will try to render the user
    interface of our widget.

    There are various ways to render a widget. The most common two are

    * to render the widget's UI by appending HTML before the widget's script
    tag.
    * to render the widget's UI by explicityl specifying a target location.

    The former technique involves traversing the publisher's DOM, locating the
    instance or instances of widget bootloader scripts, and injecting HTML before
    each script.

    While in the latter, we explicity specify placeholder HTML tags as an anchor
    position to render the widget.

    We'll continue our example with the second implementation, since it gives
    more flexibility, less prone to errors and race conditions (in the case
    of having more than one script on the page), requires less lines of code
    to implement, is a better demonstration of separation of concerns
    (script does what it should: initialization,
    and placeholder tags better represent their purpose: a place that the wiget
    bootloader (controller) will initialize the presentation (view) elements)


    Let's start by adding a div with a special attribute on the publisher
    for our script to reckognize.

    body(lang='en')
        section#Main
            h2 Welcome to Publisher Website

            p Hello World.

            div(data-wd-anchor)

            p Hello Stars.

            p Hello Universe.

    The div with the attribute data-wd-anchor will be the place to put our
    widget's HTML.

    //getElementsByTagName returns a "live" nodelist, discuss it's
    //characteristics.

    /*
     * Renders the widget
     */
    function render(state) {
        log('o->render(');
        log(state);
        log(')');

        var div = getWidgetAnchor();

        if (!div) {
            return;
        }

        div.innerHTML = state.data;
    }

    Where getWidgetAnchor is:

    /*
     * Find a place to append the widget UI.
     */
    function getWidgetAnchor() {
        log('o->getWidgetAnchor()');

        var div = null;
        var i   = 0;

        div = document.getElementsByTagName(kDiv)[i];

        while (div) {
            if (div.hasAttribute(kWidgetAnchor)) {
                log(':');
                log(div);

                return div;
            }

            div = document.getElementsByTagName(kDiv)[++i];
        }

        log(':');
        log(null);

        return null;
    }

Note:
If you have followed all the tutorials this far, you migh have seen that
the size of our bootloader is growing as we add more and more feature.
Currently this size is manageable, however after a certain limit, you may
want to submodules for each logical group, and either lazy-load them
or load it while loading the initial dependencies.
I'm trying to bring this tutorial series to a somewhat complete state
before my seminar in jstanbul 2012, so I won't have time for this refactoring
right now. However we'll be doing this refactoring, along with certain
security enhancements, deplyoyment scripts, compression and minification
in the upcomin tutorials.

    When you run the server at this point and visit http://publisher.www:8080/
    you'll see a very unstyled login box. To bring some aesthetics and
    functionality we need to include style declerations to our widget.

    There are different ways of doing this:

    We can use inline styles

    <div style="background:#aaccff;border:1px solid">...</div>

    Loading our CSS file as a dependency,

    Lazy-loading our CSS file before rendering the widget

    Embedding CSS in JavaScript and directly appending them to a newly-created
    style element.

    Again, each of these approaches has their own pros and cons. In this
    tutorial we'll take the "lazy load" approach:

    add a couple of more files to the dependencies.
    Note that these will need minimization, since they are growin in
    number and each dependency is a HTTP request in an of itself.

    /*
     * Load necessary o2.js components in noConflict mode.
     */
    function loadDependencies(callback) {
        log('o->loadDependencies(');
        log(callback);
        log(')');

        setReadyState(kLoadingDependencies);

        loadScripts(kO2Root, [
            'o2.meta.js',
            'o2.core.js',
            'o2.string.core.js',
            'o2.jsonp.core.js',
            'o2.dom.constants.js',
            'o2.dom.core.js',
            'o2.dom.load.js'
        ], callback);
    }

    Here's our widget.css just to test things:

body {background: red;}

and

    /*
     * Renders the widget
     */
    function render(state) {
        log('o->render(');
        log(state);
        log(')');

        var div = getWidgetAnchor();

        if (!div) {
            return;
        }

        o2.Dom.loadCss(
            o2.String.concat(kApiRoot, kCssPath),
            function() {
                renderWidget(div, state.data);
            }
        );
    }

and

    /*
     * Does the actual rendering.
     */
    function renderWidget(container, html) {
        log('o->renderWidget(');
        log(container);
        log(html);
        log(')');

        if (!container) {
            return;
        }

        container.innerHTML = html;
    }

when we do this we'll see that the background of the publisher's website will
becom red. Remember? We don't own publisher's DOM, so we have to constraint
our changes to our widget only.

Styling requires a lot of testing since unless you're injecting your widget
with an Iframe (and there are very good reasons to do so one of which is
preserving the look and feel), the publisher styles has a possibility to
override yours.
One drawback of Iframes is to adjust the height of them,
plus you cannot render outside the iframe boundary, so using a modal overlay
will require some additional coordination, since you need to render the
 overlay outside the iframe.

    look and feel?
    shall it look the same at every platform?
    shall it inherit some of the publisher's styles?
    to what extent?

    overspecify CSS
    overusing !important


    var config = getConfiguration();

    config[kGuid] = o2.String.generateGuid();

    loadInitialState(config, processPostInitialization);


///

        /**
         *
         */
        app.get(v_0_1(route).PARAMS, function(req, res) {
            var callback    = req.param(parameter.CALLBACK);
            var publisherId = req.param(parameter.PUBLISHER_ID);
            var guid        = req.param(parameter.GUID);

            if (!callback) {
                res.send(kNoData);
            }

            if (!publisherId) {
                res.send(kNoData);
            }

            if (!guid) {
                res.send(kNoData);
            }

            // very primitive access control.
            if (publisherId !== '123456') {
                res.send(kNoData);

                return;
            }

            var result = {
                data : createLoginForm({guid : guid})
            };

            res.send(
                callback + '(' + JSON.stringify(result) + ');'
            );
        });

    which will render this html:

    //html.





    A simple login form:



    make this a jade template and test.

    then request and cache

    Since this is a demo app, we will implement only basic functionality and
    leave further improvements as an excercise to the reader.


    TODO:
    mention different ways to render the widget.
    one option is to decouple the render targets by making the publisher
    specify the render targets separately.
    This will enable us render multiple widgets with just a single bootloader
    script.



    {{get widget state/model from the server
        corollary: create a communication channel.
            different sorts of channels.
    }}
    {{render widget}}
    {{add some basic style information
        corollary: ways to include that style information.
        }}


    how the queue is processed?
        - before widget is initialized
        - after widget is initialized.

    asyncinit.

Part 6:

    {{handling sessions}}
    {{how to authenticate user}}
    {{third party cookies}}

Part 7:

    {{retrieving data from server, modifying it, persisting it to server}}

Part 8:
    {{Deployment and Minification}}
    {{Versioning}}


---- supporting text -------

- cross-domain messaging alternatives (klein bottle)
- (at any phase mention all approaches and use the simplest one)

http://www.stevesouders.com/blog/2012/05/22/self-updating-scripts/

caching issues:
A bootstrap script is defined as a 3rd party script with a hardwired URL that can’t be changed. We want to give these scripts long cache times so they don’t slow down the page, but we also want the cached version to get updated when there’s a change. There are two main problems to solve: notifying the browser when there’s an update, and replacing the cached bootstrap script with the new version.
via:

--- supporting text ---

first (ideal case)
    authenticate user,
    remember the user.

seamless iframes:
    http://benvinegar.github.com/seamless-talk/#/39
    for those who want consistent styling and a stricter control in a
    well-defined sandbox environment.

a node.js application that
1. asks for credentials of the user.
2. displays logged in gui
3. resdisplays the logged in gui after refresh
4. the gui will have name surname and details of the user and an editable
text area
5. the text will update after user tpyes stuff
6. refreshing will retrieve the updated text from server.


- ideal case: 3rd party cookies are enabled
- detect whether they are enabled
- if disabled
    use cross frame messaging api if supported
    otherwise use klein bottle.

    mention that these should be enough and cross frame messaging api appears
    to be more widely supported in the future.

    mention easyxdm as well.


my next blog post will be about JS widgets for external sites.


TODO: look at notational data links as well.


1. What is a JavaScript Widget

2. Typical Use Cases for JavaScript Widgets

3. Challenges


Minification

split into logical pieces,
use modules
-- give examples


do use namespaces --
-- give examples